#!/usr/bin/env python3
"""
Network Manager for RPi4 OBD2 Datalogger
Handles AP mode and Client mode configuration with proper file generation
"""

import os
import subprocess
import logging
import time
from pathlib import Path

logger = logging.getLogger(__name__)

class NetworkManager:
    """Manages WiFi network configuration for AP and Client modes."""
    
    def __init__(self):
        self.hostapd_conf = "/etc/hostapd/hostapd.conf"
        self.dnsmasq_conf = "/etc/dnsmasq.conf"
        self.dhcpcd_conf = "/etc/dhcpcd.conf"
        self.wpa_supplicant_conf = "/etc/wpa_supplicant/wpa_supplicant.conf"
        
    def configure_ap_mode(self, ssid="datalogger", password="datalogger", interface="wlan0"):
        """
        Configure the RPi4 as a WiFi Access Point.
        
        Args:
            ssid: Network name for the access point
            password: Password for the access point (min 8 chars)
            interface: WiFi interface to use (default: wlan0)
        """
        logger.info(f"üåê Configuring AP Mode: {ssid}")
        
        try:
            # Generate hostapd configuration
            hostapd_config = f"""# RPi4 OBD2 Datalogger - Access Point Configuration
# Generated by network_manager.py

interface={interface}
driver=nl80211
ssid={ssid}
hw_mode=g
channel=7
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase={password}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
"""
            
            # Generate dnsmasq configuration
            dnsmasq_config = f"""# RPi4 OBD2 Datalogger - DHCP/DNS Configuration
# Generated by network_manager.py

interface={interface}
dhcp-range=192.168.4.2,192.168.4.20,255.255.255.0,24h
domain=local
address=/datalogger.local/192.168.4.1
"""
            
            # Generate dhcpcd configuration for static IP
            dhcpcd_config = f"""# RPi4 OBD2 Datalogger - Static IP Configuration
# Generated by network_manager.py

# Static IP configuration for AP mode
interface {interface}
static ip_address=192.168.4.1/24
nohook wpa_supplicant
"""
            
            # Backup existing files
            self._backup_config_file(self.hostapd_conf)
            self._backup_config_file(self.dnsmasq_conf)
            self._backup_config_file(self.dhcpcd_conf)
            
            # Write new configuration files
            self._write_config_file(self.hostapd_conf, hostapd_config)
            self._write_config_file(self.dnsmasq_conf, dnsmasq_config)
            self._write_config_file(self.dhcpcd_conf, dhcpcd_config)
            
            # Enable and configure services
            self._enable_ap_services()
            
            logger.info("‚úÖ AP Mode configuration complete!")
            logger.info(f"üì° Network: {ssid} | Password: {password}")
            logger.info("üåê Access Point IP: 192.168.4.1")
            logger.info("üîß Reboot required for changes to take effect")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Failed to configure AP mode: {e}")
            return False
    
    def configure_client_mode(self, ssid, password, interface="wlan0"):
        """
        Configure the RPi4 to connect to an existing WiFi network.
        
        Args:
            ssid: Network name to connect to
            password: Network password
            interface: WiFi interface to use (default: wlan0)
        """
        logger.info(f"üåê Configuring Client Mode: {ssid}")
        
        try:
            # Generate wpa_supplicant configuration
            wpa_config = f"""# RPi4 OBD2 Datalogger - WiFi Client Configuration
# Generated by network_manager.py

ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=US

network={{
    ssid="{ssid}"
    psk="{password}"
    key_mgmt=WPA-PSK
}}
"""
            
            # Generate dhcpcd configuration for DHCP
            dhcpcd_config = f"""# RPi4 OBD2 Datalogger - DHCP Client Configuration
# Generated by network_manager.py

# Enable DHCP for client mode
interface {interface}
"""
            
            # Backup existing files
            self._backup_config_file(self.wpa_supplicant_conf)
            self._backup_config_file(self.dhcpcd_conf)
            
            # Write new configuration files
            self._write_config_file(self.wpa_supplicant_conf, wpa_config)
            self._write_config_file(self.dhcpcd_conf, dhcpcd_config)
            
            # Disable AP services and enable client mode
            self._enable_client_services()
            
            logger.info("‚úÖ Client Mode configuration complete!")
            logger.info(f"üì° Connecting to: {ssid}")
            logger.info("üîß Reboot required for changes to take effect")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Failed to configure client mode: {e}")
            return False
    
    def _backup_config_file(self, filepath):
        """Create a backup of existing configuration file."""
        if os.path.exists(filepath):
            backup_path = f"{filepath}.backup"
            try:
                subprocess.run(['sudo', 'cp', filepath, backup_path], check=True)
                logger.info(f"üìÅ Backed up {filepath} to {backup_path}")
            except subprocess.CalledProcessError as e:
                logger.warning(f"‚ö†Ô∏è  Could not backup {filepath}: {e}")
    
    def _write_config_file(self, filepath, content):
        """Write configuration content to file with sudo privileges."""
        try:
            # Write to temporary file first
            temp_file = f"/tmp/{os.path.basename(filepath)}.tmp"
            with open(temp_file, 'w') as f:
                f.write(content)
            
            # Move to final location with sudo
            subprocess.run(['sudo', 'mv', temp_file, filepath], check=True)
            subprocess.run(['sudo', 'chmod', '644', filepath], check=True)
            
            logger.info(f"üìù Written configuration to {filepath}")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to write {filepath}: {e}")
            raise
    
    def _enable_ap_services(self):
        """Enable and configure services for AP mode."""
        commands = [
            ['sudo', 'systemctl', 'disable', 'wpa_supplicant'],
            ['sudo', 'systemctl', 'enable', 'hostapd'],
            ['sudo', 'systemctl', 'enable', 'dnsmasq'],
            ['sudo', 'systemctl', 'unmask', 'hostapd'],
            ['sudo', 'update-rc.d', 'hostapd', 'enable'],
            ['sudo', 'update-rc.d', 'dnsmasq', 'enable']
        ]
        
        for cmd in commands:
            try:
                subprocess.run(cmd, check=True, timeout=10)
                logger.info(f"‚úÖ Executed: {' '.join(cmd)}")
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
                logger.warning(f"‚ö†Ô∏è  Command failed: {' '.join(cmd)} - {e}")
    
    def _enable_client_services(self):
        """Enable and configure services for client mode."""
        commands = [
            ['sudo', 'systemctl', 'disable', 'hostapd'],
            ['sudo', 'systemctl', 'disable', 'dnsmasq'],
            ['sudo', 'systemctl', 'enable', 'wpa_supplicant'],
            ['sudo', 'systemctl', 'enable', 'dhcpcd']
        ]
        
        for cmd in commands:
            try:
                subprocess.run(cmd, check=True, timeout=10)
                logger.info(f"‚úÖ Executed: {' '.join(cmd)}")
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
                logger.warning(f"‚ö†Ô∏è  Command failed: {' '.join(cmd)} - {e}")
    
    def restart_networking(self):
        """Restart network services."""
        logger.info("üîÑ Restarting network services...")
        
        commands = [
            ['sudo', 'systemctl', 'daemon-reload'],
            ['sudo', 'systemctl', 'restart', 'dhcpcd'],
            ['sudo', 'systemctl', 'restart', 'hostapd'],
            ['sudo', 'systemctl', 'restart', 'dnsmasq']
        ]
        
        for cmd in commands:
            try:
                subprocess.run(cmd, check=True, timeout=15)
                logger.info(f"‚úÖ Restarted: {' '.join(cmd)}")
                time.sleep(2)  # Give services time to start
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
                logger.warning(f"‚ö†Ô∏è  Restart failed: {' '.join(cmd)} - {e}")
    
    def get_network_status(self):
        """Get current network configuration and status."""
        status = {
            "mode": "unknown",
            "interface": "wlan0",
            "ip_address": None,
            "ssid": None,
            "connected": False
        }
        
        try:
            # Check if hostapd is running (AP mode)
            result = subprocess.run(['sudo', 'systemctl', 'is-active', 'hostapd'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                status["mode"] = "AP"
                status["ip_address"] = "192.168.4.1"
                status["connected"] = True
                
                # Try to get SSID from hostapd config
                try:
                    with open(self.hostapd_conf, 'r') as f:
                        for line in f:
                            if line.startswith('ssid='):
                                status["ssid"] = line.split('=', 1)[1].strip()
                                break
                except:
                    pass
            else:
                # Client mode - check wpa_supplicant
                result = subprocess.run(['iwgetid', '-r'], capture_output=True, text=True)
                if result.returncode == 0:
                    status["mode"] = "Client"
                    status["ssid"] = result.stdout.strip()
                    status["connected"] = True
                    
                    # Get IP address
                    result = subprocess.run(['hostname', '-I'], capture_output=True, text=True)
                    if result.returncode == 0:
                        status["ip_address"] = result.stdout.strip().split()[0]
        
        except Exception as e:
            logger.error(f"Error getting network status: {e}")
        
        return status

def test_network_manager():
    """Test function to verify network manager functionality."""
    nm = NetworkManager()
    
    print("üß™ Testing Network Manager...")
    print("üìä Current Status:")
    status = nm.get_network_status()
    for key, value in status.items():
        print(f"   {key}: {value}")
    
    print("\n‚úÖ Network Manager test complete!")

if __name__ == "__main__":
    test_network_manager()